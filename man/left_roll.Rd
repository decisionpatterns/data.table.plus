% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/left_roll.R
\name{left_roll}
\alias{left_roll}
\title{Left or right rolling join}
\usage{
left_roll(x, y, on, roll, ...)
}
\arguments{
\item{x, }{y data.table}

\item{on}{character vector of join columns. The last is the join column}

\item{roll}{direction and allowed size of the roll. see ?data.table.}

\item{...}{additional arguments passed to \code{\link{setprefix}} (unimplemented)}
}
\value{
a data.table object with
}
\description{
Perform rolling join
}
\details{
It is best to think of x as the m
\subsection{Duplicated y's}{
\enumerate{
\item It is often expected that \code{nrow(results)} equals
\code{nrow(x)}. This is not true when are duplicated rows in y; it maybe important to
the application to dedupe the rows of y before joining?
\item When deduping y, ensure that you are taking the correct duplicate.
`unique`` retains the first occerence.
}
}
}
\note{
\itemize{
\item The name \code{roll} comes from the data.table/ts rolling joins
\item \code{zip} is also an interesting name -- zipping on a fields with
\code{roll} telling what to do first
}
}
\examples{

set.seed(1)
x <- data.table(
         letter=sample(letters[1:2],10, replace=TRUE)
       , year_x=sample( 2000:2010, 10, replace=TRUE )
     )
x <- x[ order(letter, year_x) ]
#' x <- unique(x)

y <- data.table(
         letter=sample(letters[1:2],5, replace=TRUE)
       , year_y=sample( 2000:2010, 5, replace=TRUE )
     )
y <- y[ order(letter, year_y) ]
y <- unique(y)
y

# on=c('letter','year')
on=c('letter',year_x='year_y')
roll=Inf


ret <- left_roll(x,y,on=on,roll=roll)
ret[ letter=="a"]; x[letter=="a"]; y[ letter=="a"]
ret[ letter=="b"]; x[letter=="b"]; y[ letter=="b"]


}
\seealso{
\itemize{
\item \link{setprefix}
\item \code{\link[dplyr:left_join]{dplyr::left_join()}}
\item \verb{data.table::[.data.table}
}
}
\author{
Decision Patterns
}
